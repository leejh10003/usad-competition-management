
// ----------------------------------------
// Enums for data consistency
// ----------------------------------------


enum Division {
  H // Honors
  S // Scholastic
  V // Varsity
}


// ----------------------------------------
// Main Data Models
// ----------------------------------------

model School {
  // Internal, immutable UUID for stable relations.
  id String @id @default(uuid()) @db.Uuid

  // Business-facing ID provided by USAD.
  externalSchoolId String? @unique @map("external_school_id")

  name      String
  isVirtual Boolean @default(false) @map("is_virtual")

  streetAddress  String? @map("street_address")
  city           String?
  state          String?
  zipCode        String? @map("zip_code")
  phone          String?
  principalName  String? @map("principal_name")
  principalEmail String? @map("principal_email")

  // The school's primary coach. Enforces the "one primary coach per school" rule.
  primaryCoachId String? @unique @map("primary_coach_id") @db.Uuid
  primaryCoach   Coach?  @relation("PrimaryCoachOfSchool", fields: [primaryCoachId], references: [id])

  // The email domain is a property of the School, derived from the primary coach.
  emailDomain String? @unique @map("email_domain")

  // Relations
  coaches  Coach[] @relation("CoachesOfSchool")
  teams    Team[]
  students Student[]

  @@map("schools")
}

model Team {
  id String @id @default(uuid()) @db.Uuid

  // Team ID #, unique only within a specific school.
  externalTeamId String? @map("external_team_id")

  // Foreign key to the School.
  schoolId String @map("school_id") @db.Uuid
  school   School @relation(fields: [schoolId], references: [id])

  coachesRelationship TeamCoachRelationship[] @relation("TeamRelationshipToCoach")

  // 1-N relationship: A team has multiple students.
  students Student[]

  @@map("teams")
}

model TeamCoachRelationship {
  teamId String @map("team_id") @db.Uuid
  team Team @relation("TeamRelationshipToCoach", fields: [teamId], references: [id])
  coachId String @map("coach_id") @db.Uuid
  coach Coach @relation("CoachRelationshipToTeam", fields: [coachId], references: [id])
  @@id([teamId, coachId])
}

model Coach {
  id String @id @default(uuid()) @db.Uuid

  // Business-facing ID provided by USAD.
  externalCoachId String? @unique @map("external_coach_id")

  firstName String @map("first_name")
  lastName  String @map("last_name")
  email     String @unique
  phone     String?

  // Every coach must belong to exactly one school.
  schoolId String @map("school_id") @db.Uuid
  school   School @relation("CoachesOfSchool", fields: [schoolId], references: [id])

  // The school where this coach is designated as the primary. (Will be null for assistants).
  primarySchool School? @relation("PrimaryCoachOfSchool")

  // M-N relationship with Team. Prisma will manage the implicit join table.
  teamRelationship TeamCoachRelationship[] @relation("CoachRelationshipToTeam")
  signature String?

  @@map("coaches")
}

model Student {
  id String @id @default(uuid()) @db.Uuid

  // The globally unique, concatenated ID provided by USAD.
  externalStudentId String? @unique @map("external_student_id")

  division  Division
  gpa       Float?
  firstName String @map("first_name")
  lastName  String @map("last_name")
  usadPin   String? @map("usad_pin")

  // Every student must belong to a team (even if it's a virtual "Individuals" team).
  teamId String? @map("team_id") @db.Uuid
  team   Team?   @relation(fields: [teamId], references: [id])

  // Every student belongs to a school.
  schoolId String? @map("school_id") @db.Uuid
  school   School? @relation(fields: [schoolId], references: [id])
  signature String?
  eventCheckIns EventCheckIn[] @relation("StudentOfEventCheckIn")

  streetAddress  String? @map("street_address")
  city           String?
  state          String?
  zipCode        String? @map("zip_code")

  @@map("students")
}

model Event {
  id String @id @default(uuid()) @db.Uuid
  name String
  startsAt DateTime @map("starts_at") @db.Timestamptz(3)
  eventCheckIn EventCheckIn[] @relation("EventOfEventCheckIn")
  @@map("events")
}

model EventCheckIn {
  studentId String @db.Uuid
  student Student @relation("StudentOfEventCheckIn", fields: [studentId], references: [id])
  eventId String @db.Uuid
  event Event @relation("EventOfEventCheckIn", fields: [eventId], references: [id])
  checkedInAt DateTime @map("cheked_in_at") @db.Timestamptz(3)
  @@id([studentId, eventId])
  @@map("event_check_ins")
}