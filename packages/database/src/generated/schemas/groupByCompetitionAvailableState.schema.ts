import type { Prisma } from '@prisma/client';
import * as z from 'zod';
import { CompetitionAvailableStateWhereInputObjectSchema as CompetitionAvailableStateWhereInputObjectSchema } from './objects/CompetitionAvailableStateWhereInput.schema';
import { CompetitionAvailableStateOrderByWithAggregationInputObjectSchema as CompetitionAvailableStateOrderByWithAggregationInputObjectSchema } from './objects/CompetitionAvailableStateOrderByWithAggregationInput.schema';
import { CompetitionAvailableStateScalarWhereWithAggregatesInputObjectSchema as CompetitionAvailableStateScalarWhereWithAggregatesInputObjectSchema } from './objects/CompetitionAvailableStateScalarWhereWithAggregatesInput.schema';
import { CompetitionAvailableStateScalarFieldEnumSchema } from './enums/CompetitionAvailableStateScalarFieldEnum.schema';
import { CompetitionAvailableStateCountAggregateInputObjectSchema as CompetitionAvailableStateCountAggregateInputObjectSchema } from './objects/CompetitionAvailableStateCountAggregateInput.schema';
import { CompetitionAvailableStateMinAggregateInputObjectSchema as CompetitionAvailableStateMinAggregateInputObjectSchema } from './objects/CompetitionAvailableStateMinAggregateInput.schema';
import { CompetitionAvailableStateMaxAggregateInputObjectSchema as CompetitionAvailableStateMaxAggregateInputObjectSchema } from './objects/CompetitionAvailableStateMaxAggregateInput.schema';

export const CompetitionAvailableStateGroupBySchema: z.ZodType<Prisma.CompetitionAvailableStateGroupByArgs> = z.object({ where: CompetitionAvailableStateWhereInputObjectSchema.optional(), orderBy: z.union([CompetitionAvailableStateOrderByWithAggregationInputObjectSchema, CompetitionAvailableStateOrderByWithAggregationInputObjectSchema.array()]).optional(), having: CompetitionAvailableStateScalarWhereWithAggregatesInputObjectSchema.optional(), take: z.number().optional(), skip: z.number().optional(), by: z.array(CompetitionAvailableStateScalarFieldEnumSchema), _count: z.union([ z.literal(true), CompetitionAvailableStateCountAggregateInputObjectSchema ]).optional(), _min: CompetitionAvailableStateMinAggregateInputObjectSchema.optional(), _max: CompetitionAvailableStateMaxAggregateInputObjectSchema.optional() }).strict() as unknown as z.ZodType<Prisma.CompetitionAvailableStateGroupByArgs>;

export const CompetitionAvailableStateGroupByZodSchema = z.object({ where: CompetitionAvailableStateWhereInputObjectSchema.optional(), orderBy: z.union([CompetitionAvailableStateOrderByWithAggregationInputObjectSchema, CompetitionAvailableStateOrderByWithAggregationInputObjectSchema.array()]).optional(), having: CompetitionAvailableStateScalarWhereWithAggregatesInputObjectSchema.optional(), take: z.number().optional(), skip: z.number().optional(), by: z.array(CompetitionAvailableStateScalarFieldEnumSchema), _count: z.union([ z.literal(true), CompetitionAvailableStateCountAggregateInputObjectSchema ]).optional(), _min: CompetitionAvailableStateMinAggregateInputObjectSchema.optional(), _max: CompetitionAvailableStateMaxAggregateInputObjectSchema.optional() }).strict();